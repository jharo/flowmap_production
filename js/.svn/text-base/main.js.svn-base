//definition of the global objects we are going to use in the application
var METERSPERSEC_MILESPERHOUR_FACTOR = 2.23693629;

//the google map obeject
var map;

//the weborb proxy object
var proxy;

//the timer objects. appTimer is the timer for the entire application, it will drive the refresh interval and the clock updates.
//cameraTimer is the timer object for when the camera icon is clicked. it will refresh the camera image.
var appTimer;
appTimer = new Timer();
appTimer.Interval = 1000;
var cameraTimer;
cameraTimer = new Timer();
cameraTimer.Interval = 2000;

//these are the default images for the cctv icons
var cctv_good = "img/cctv/cctv_good.png";
var cctv_fail = "img/cctv/cctv_fail.png";

//these are the default images for the logos
var logo_mta = "img/logos/mtaLogo.gif";
var logo_nyc = "img/logos/dotLogo_g.gif";
var logo_nys = "img/logos/nysdot_logo2.gif";

//these are for the reader location icons
var readerLocationIcon = "img/icons/bullet_green.png";

//the vars below are used for the marker cluster and marker cluster styles
//markerCluster is the MarkerCluster object to clluster the cameras together. it is defined by the MarkerCluster Library.
//myCameraMarkers is an array that is used by the MarkerCluster class to cluster the cameras together. it is also used to hide the cameras overlay using the menu
//cctvClusterStyle are the styles array for the markercluster using my own icons for the cctv obejcts
var markerCluster;
var myCameraMarkers = new Array();
var cctvClusterStyle = [
{
	url : "img/cctv/cluster/cctv_blue.png",
	height : 40,
	width : 40,
	anchor : [20, 0],
	textColor : "#000000",
	textSize : 14
},
{
	url : "img/cctv/cluster/cctv_yellow.png",
	height : 50,
	width : 50,
	anchor : [25, 0],
	textColor : "#000000",
	textSize : 16
},
{
	url : "img/cctv/cluster/cctv_red.png",
	height : 60,
	width : 60,
	anchor : [30, 0],
	textColor : "#444444",
	textSize : 18
},
{
	url : "img/cctv/cluster/cctv_pink.png",
	height : 70,
	width : 70,
	anchor : [35, 0],
	textColor : "#444444",
	textSize : 20
},
{
	url : "img/cctv/cluster/cctv_purple.png",
	height : 80,
	width : 80,
	anchor : [40, 0],
	textColor : "#444444",
	textSize : 22
}];

//we define an infowindow object to hold the camera image.
var cameraInfoWindow = new google.maps.InfoWindow();

//mimLocations is an array that will hold the markers where the mim locations are installed. it will also be used to show/hide the overlay using the menu
var readerLocations = new Array();

//mimLinks is an array that will hold the traveltime links overlay objects once created on the map. we will also used these to hide them from the menu
var mimLinks = new Array();
//linkToolTip is an InfoBox class object that will appear when the user mouseover the link. it is defined by the Infobox class library
var linkToolTip = new InfoBox(
{
	closeBoxURL : "",
	boxClass : "tooltip",
	disableAutoPan : true,
	maxWidth : 0,
	pixelOffset : new google.maps.Size(10, 10)

});
var myTime;
var myDate;

var defaultPolylineColorOptions =
{
	strokeWeight : 3,
	strokeOpacity : 1
};
var onPolylineHoverColorOptions =
{
	strokeWeight : 10,
	strokeOpacity : .85
};

//dataRefreshInterval_seconds is the amount of time that will pass before the timer resets and grabs new data for the links
//it used primaraly by the timer function and reset by it.
var dataRefreshInterval_seconds = 60;

//secondsToNextREfresh is a global var that will provide the amount of seconds to the next refresh.
//by default it is set to the number of dataREfreshInterval_seconds and it is updated by the timer function
var secondsToNextRefresh = dataRefreshInterval_seconds;

//function to ini the map
function initialize()
{
	var customMapStyle = createMyMapStyle();
	var styledMap = new google.maps.StyledMapType(customMapStyle,
	{
		name : "tmc"
	});

	var mapOptions =
	{
		center : new google.maps.LatLng(40.71462, -74.006600),
		zoom : 11,
		streetViewControl : true,
		streetViewControlOptions :
		{
			position : google.maps.ControlPosition.LEFT_TOP
		},
		zoomControl : false,
		panControl : false,
		scaleControl : true,
		mapTypeControl : false,
		mapTypeControlOptions :
		{
			mapTypeIds : [google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.SATELLITE, google.maps.MapTypeId.HYBRID, "map_style"],
			style : google.maps.MapTypeControlStyle.DROPDOWN_MENU,
			position : google.maps.ControlPosition.TOP_LEFT
		}
	};

	map = new google.maps.Map(document.getElementById("mapCanvas"), mapOptions);
	map.mapTypes.set("map_style", styledMap);
	map.setMapTypeId("map_style");
	google.maps.event.addListenerOnce(map, 'tilesloaded', ontilesloaded);
	//map.setOptions({styles:customMapStyle});

	//here we add a set of custom map controls. The controls are stored in the 'myCustomControls.js' file
	var mOptions =
	{
		gmap : map,
		position : google.maps.ControlPosition.TOP_RIGHT,

	};

	var dOptions =
	{
		gmap : map,
		position : google.maps.ControlPosition.RIGHT_BOTTOM,
		message : 'The link colors are derived from the aggregation of the last 15 minutes of data<br>The last data update occurred on: '
	};
	var legendOptions =
	{
		gmap : map,
		legendTitle : 'Legend',
		position : google.maps.ControlPosition.RIGHT_BOTTOM,

	};

	var myMenuControl = new myMapMenuCntrl(mOptions);
	var myMessageControl = new mapDesclaimer(dOptions);
	var myLegendControl = new mapLegend(legendOptions);

	//set the timer
	appTimer.Tick = mytick;
	appTimer.Enable = true;
	appTimer.Start();

}

/**
 *
 * mytick is the main timer function for the application. It must be defined for the 'appTimer' object.
 *  it will drive the time and date components and more importantly it drives the refresh interval of the link data.
 * the method is called each timer the timer ticks (refreshes) according to the timer definition.
 */
function mytick()
{
	//console.log("from timer tick: "+new Date() + ", and current count: "+appTimer.currentCount);
	myTime = moment().format('hh:mm:ss a');
	myDate = moment().format('dddd, MMMM Do');

	document.getElementById("timeDiv").innerHTML = myTime;
	document.getElementById("dateDiv").innerHTML = myDate;
	document.getElementById("timeLeft").innerHTML = "Seconds left until next refresh: " + (secondsToNextRefresh--);
	//console.log(myDate+" "+myTime+" timer current count: "+appTimer.currentCount);
	if (appTimer.currentCount == dataRefreshInterval_seconds)
	{
		//refresh the MIM data
		//console.log('refreshing data');
		getMimData();
		//reset the timer so the current count resets as well
		appTimer.Reset();
		document.getElementById("disclaimerDateTime").innerHTML = moment().format('MMMM Do YYYY, h:mm:ss a');
		secondsToNextRefresh = dataRefreshInterval_seconds;
	}

};
/**
 *
 * createMyMapStyle simply returns the custom google maps stylers
 *
 */
function createMyMapStyle()
{

	var style = new Array();

	style = [
	{
		featureType : "transit",
		stylers : [
		{
			visibility : "off"
		}]
	},
	{
		featureType : "poi",
		stylers : [
		{
			visibility : "off"
		}]
	},
	{
		featureType : "landscape",
		stylers : [
		{
			visibility : "on"
		},
		{
			saturation : -100
		},
		{
			lightness : 62
		}]
	},
	{
		featureType : "road.highway",
		elementType : "geometry",
		stylers : [
		{
			visibility : "on"
		},
		{
			saturation : -100
		},
		{
			lightness : 40
		}]
	},
	{
		featureType : "road.arterial",
		stylers : [
		{
			visibility : "on"
		},
		{
			saturation : -100
		},
		{
			lightness : 30
		}]
	},
	{
		featureType : "road.local",
		stylers : [
		{
			visibility : "on"
		},
		{
			saturation : -100
		},
		{
			lightness : 20
		}]
	},
	{
		featureType : "administrative.locality",
		stylers : [
		{
			visibility : "off"
		}]
	},
	{
		featureType : "road.highway",
		elementType : "labels.text",
		stylers : [
		{
			visibility : "on"
		},
		{
			saturation : -100
		},
		{
			lightness : 10
		}]
	},
	{
		featureType : "water",
		stylers : [
		{
			visibility : "on"
		},
		{
			lightness : 30
		}]
	},
	{
	}];

	return style;
}

function invokeServer(syncMode)
{

	var className = "flowMapSolutions_dev.EzPassData";
	var webORBURL = "http://localhost/weborb4/weborb.aspx";

	proxy = webORB.bind(className, webORBURL);

	proxy.getMidtownEzPassLocations(new Async(successReaderLocation, errorDownloadingData));
	proxy.getMidtownEzpassLinks(new Async(successMimPolylines, errorDownloadingData));
	proxy.getWebCameras(new Async(successGotCamera, errorDownloadingData));

}

function successReaderLocation(results)
{
	if (results.length != 0 || results != null)
	{
		for (var i = 0; i < results.length; i++)
		{
			var readerLocation = createReaderMarker(results[i]);
			readerLocations.push(readerLocation);
		}
		document.getElementById("readerLocationsNumber").innerHTML += " " + results.length;

	}
}

function createReaderMarker(readerLocationObj)
{
	var locationCoords = new google.maps.LatLng(readerLocationObj.lat, readerLocationObj.lng);
	var markerIcon =
	{
		url : readerLocationIcon,
		size : new google.maps.Size(32, 32),
		origin : new google.maps.Point(0, 0),
		anchor : new google.maps.Point(16, 16)
	};
	var readerMarker = new google.maps.Marker(
	{
		position : locationCoords,
		map : map,
		icon : markerIcon,
		title : readerLocationObj.name + " (location ID: " + readerLocationObj.lid + ")"
	});

	return readerMarker;
}

//-----------------------------------------polyline link functions-------------------------------------------------------//

function successMimPolylines(results)
{
	if (results != null && results.length != 0)
	{
		for (var i = 0; i < results.length; i++)
		{
			var polyline = createExistingPolyline(results[i]);
			polyline.setMap(map);
			mimLinks.push(polyline);
		}

		document.getElementById("linkNumber").innerHTML += " " + results.length;
		results = [];
		getMimData();
	}
	else
	{
		alert("no polylines found on server");
	}
}

function errorDownloadingData(error)
{
	console.log(error);
}

/**
 *createPolyine is an internal function that will create a gogle polyline from the information in the linkInfo object.
 * @param {object} An object with the link information neccessary to make a polyline. usually this object will have the encoded polyline string and their level
 * @return a Google polyline
 */
function createExistingPolyline(linkInfo)
{
	var polyPath = google.maps.geometry.encoding.decodePath(linkInfo.polylineString);
	//create an arrow path object to add to the polyline
	var arrowSymbol =
	{
		path : google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
		scale : 2,
		strokeColor : '#000000',
		strokeWeight : 1,
		fillOpacity : 1,
		fillColor : '#444444'
	};
	var mypoly = new google.maps.Polyline(
	{
		path : polyPath,
		geodesic : true,
		strokeColor : '#444444',
		strokeOpacity : 1,
		strokeWeight : 2,
		icons : [
		{
			icon : arrowSymbol,
			offset : '50%'
		}],
	});

	mypoly.linkName = linkInfo.linkName;
	mypoly.sid = linkInfo.linkSid;
	mypoly.lid0 = linkInfo.lid0;
	mypoly.lid1 = linkInfo.lid1;
	mypoly.middlepoint = getMostMiddlePoint(polyPath);
	mypoly.linkLength = google.maps.geometry.spherical.computeLength(mypoly.getPath()).toFixed(2);
	mypoly.medianTtSeconds = 0;
	mypoly.medianSpeedMph = 0;
	mypoly.medianTtString = 'undefined';
	mypoly.medianTtDatetime = new Date();
	mypoly.numberOfRecords = 0;
	mypoly.linkColor = 'undefined';

	google.maps.event.addListener(mypoly, 'click', onPolylineMouseClick);
	google.maps.event.addListener(mypoly, 'mouseover', onPolylineMouseOver);
	google.maps.event.addListener(mypoly, 'mouseout', onPolylineMouseOut);

	return mypoly;
}

function onPolylineMouseOver(e)
{
	var tooltipContent = "";
	this.setOptions(onPolylineHoverColorOptions);
	this.icons[0].icon.fillColor = this.linkColor;

	tooltipContent = "<span>" + this.linkName + "</span><hr>number of records: " + this.numberOfRecords;
	tooltipContent += "<br>approx. median travel-time: " + this.medianTtString;
	tooltipContent += "<br>approx. median speed (mph): " + this.medianSpeedMph.toFixed(2);
	tooltipContent += "<br>median record timestamp: " + moment(this.medianTtDatetime).format("M-DD-YY h:mm:ss a");
	tooltipContent += "<br>segment length: " + this.linkLength + " meters";
	tooltipContent += "<br>segment ID " + this.sid;
	tooltipContent += "<br>segment points: " + this.lid0 + " to " + this.lid1;

	linkToolTip.setContent(tooltipContent);
	//here e is the overlay object and whenever we hover over the overlay we can get the coords to use with our infobox tooltip
	linkToolTip.setPosition(e.latLng);
	linkToolTip.open(map);
}

function onPolylineMouseOut(e)
{
	this.setOptions(defaultPolylineColorOptions);
	this.icons[0].icon.fillColor = this.linkColor;
	linkToolTip.close();
}

function onPolylineMouseClick(e)
{
	//this is the actual polyline object
	showChart(this);
}

/**
 *this method will obtain the middle point of the polyline path array in order to display the infowindow at this location
 * @param {Array} an Array containing the polyline path
 */
function getMostMiddlePoint(arr)
{
	var middle = arr[Math.floor((arr.length - 1) / 2)];
	var m2 = google.maps.geometry.spherical.interpolate(arr[0], arr[arr.length - 1], .5);
	return middle;
}

function getMimData()
{
	var mimData = proxy.getSegmentsMedianTravelTimes('00:15:00');

	for (var i = 0; i < mimData.length; i++)
	{
		for (var j = 0; j < mimLinks.length; j++)
		{
			if (mimData[i].derivedSegmentId == mimLinks[j].sid)
			{
				//console.log(mimData[i].derivedSegmentId + " - " + mimLinks[j].sid + " - " + mimLinks[j].linkName);
				mimLinks[j].numberOfRecords = mimData[i].numberOfRecords;
				mimLinks[j].medianTtSeconds = mimData[i].medianTravelTime_seconds;
				mimLinks[j].medianTtString = mimData[i].medianTravelTime_string;
				mimLinks[j].medianTtDatetime = mimData[i].medianTravelTimeDate;
				mimLinks[j].medianSpeedMph = ((mimLinks[j].linkLength / mimData[i].medianTravelTime_seconds) * METERSPERSEC_MILESPERHOUR_FACTOR);

				mimLinks[j].linkColor = getColor(mimLinks[j].sid, mimLinks[j].medianTtSeconds, mimLinks[j].medianSpeedMph, mimLinks[j].numberOfRecords);
				//console.log("linkName: "+mimLinks[j].linkName+" sid:"+mimLinks[j].sid+" tt_sec:"+mimLinks[j].medianTtSeconds+" spd:"+mimLinks[j].medianSpeedMph+" nRecords:"+mimLinks[j].numberOfRecords+" - color:"+mimLinks[j].linkColor);
				mimLinks[j].setOptions(
				{
					strokeColor : mimLinks[j].linkColor
				});
				mimLinks[j].icons[0].icon.fillColor = mimLinks[j].linkColor;
				mimLinks[j].icons[0].icon.strokeColor = mimLinks[j].linkColor;

			}
		}
	}
	mimData = [];
}

//---the function that will change the link color---//
function getColor(linkSid, travelTime, speed, nRecords)
{
	//console.log("#==="+linkSid+", "+travelTime+", "+speed+", "+nRecords);
	var linkColor = 'undefined0';
	if (travelTime <= 0)
	{
		linkColor = '#444444';
	}
	else
	{
		//decide what type of color system to use using the segmentID property.
		switch (linkSid.toString()) {
			//if the segment is a local street not MIM then use the MUTCD local street speed system
			case '11771':
			case '11772':
			case '71101':
			case '10171':
			case '72117':
			case '71117':
			case '8788':
			case '8887':
			case '8889':
			case '8988':
			case '8990':
			case '9089':
			case '9091':
			case '9190':
			case '9192':
			case '9291':
			case '6563':
			case '6364':
			case '6374':
			case '7071':
			case '7170':
			case '7073':
			case '7370':
			case '123124':
			case '7462':
			case '6274':
			case '7466':
			case '6674':
			case '6667':
			case '8466':
			case '66128':
			case '124123':
			case '124125':
			case '125124':
			case '62126':
			case '12662':
			case '125127':
			case '127125':
			case '127121':
			case '121127':
			case '121126':
			case '126121':
			case '12868':
			case '7463':
			case '6768':
			case '9394':
			case '9498':
			case '9493':
			case '9894':
			case '10098':
			case '98100':
			case '111112':
			case '112111':
			case '111113':
			case '113111':
			case '11393':
			case '93113':
			case '100115':
			case '115100':
			case '131129':
			case '129131':
			case '129130':
			case '130129':
			case '6663':
			case '6366':
			case '114115':
			case '115114':
			case '8687':
			case '8786':
			case '9596':
			case '9695':
			case '9697':
			case '9986':
			case '8699':
			case '9796':
			case '9799':
			case '9997':
			//--flatbush ave links --//
			case '133134':
			case '134133':
			case '134122':
			case '122134':
			case '122135':
			case '135122':
			case '135120':
			case '120135':
			case '130139':
			case '139130':
			case '140120':
			case '120140':
				linkColor = applyLocalStreetColorSystem(speed, nRecords);
				break;
			//if the link sid is of a highway type use the highway speeds color system
			case '2426':
			case '2829':
			case '3527':
			case '2535':
			case '3425':
			case '2734':
			case '3428':
			case '2634':
			case '3324':
			case '3536':

				linkColor = applyHighwaysColorSystem(speed, nRecords);
				break;
			//as a default since this is the midtown map we will use the mim color system
			default:
				linkColor = applyMidtownInMotionColorSystem(speed, travelTime, nRecords);
				break;

		}
	}

	return linkColor;

};

/**
 * applyLocalStreetColorSystem -
 * this function changes the color of the link based on the MUTCD local street color designations
 * */
function applyLocalStreetColorSystem(speed, nRecords)
{
	var c = 'undefine1';
	if (speed > 0)
	{
		if ((nRecords < 5) && (nRecords > 0))
		{
			c = '#4E7AC7';
			//blue
		}
		else if (speed > 13.0)
		{
			c = '#32CD32';
			//green
		}
		else if ((speed <= 13.0) && (speed > 9.0))
		{
			c = '#FFDF00';
			//yellow
		}
		else if ((speed <= 9.0) && (speed > 7.0))
		{
			color = '#ffa500';
			//orange
		}
		else if (speed <= 7.0)
		{
			c = '#CC3333';
			//red
		}
	}
	else
	{
		c = '#333333';
	}
	//positionOverlay(false);
	return c;
}

function applyHighwaysColorSystem(speed, nRecords)
{
	var c = 'undefined1';
	if (speed > 0)
	{
		if ((this._totalRecordCount < 5) && (this._totalRecordCount > 0))
		{

			c = '#4E7AC7';
			//blue
		}
		else if (speed > 45.0)
		{
			c = '#32CD32';
			//green
		}
		else if ((speed <= 45.0) && (speed > 30.0))
		{
			c = '#FFDF00';
			//yellow
		}
		else if ((speed <= 30.0) && (speed > 15.0))
		{
			c = '#ffa500';
			//orange
		}
		else if (speed <= 15.0)
		{
			c = '#CC3333';
			//red
		}

	}
	else
	{
		c = '#444444';
	}
	return c;
}

function applyMidtownInMotionColorSystem(speed, travelTime, nRecords)
{
	var c = 'undefined1';
	if (speed > 0)
	{
		if ((nRecords < 5) && (nRecords > 0))
		{
			c = '#4E7AC7';
			//blue
		}
		else if (0 < travelTime && travelTime <= 180)
		{
			c = '#32CD32';
			//green
		}
		else if (180 < travelTime && travelTime <= 270)
		{
			c = '#FFDF00';
			//yellow
		}
		else if (270 < travelTime && travelTime <= 360)
		{
			c = '#ffa500';
			//orange
		}
		else if (360 < travelTime)
		{
			c = '#ff0000';
			//red
		}

	}
	else
	{
		c = '#444444';
	}
	return c;
}

//----------------------------------------- end of polyline link functions-------------------------------------------------------//

function successGotCamera(response)
{
	//this array will be used for the markercluster

	for (var i = 0; i < response.length; i++)
	{
		var item = response[i];

		//this is a temp hack while debugging. these lines MUST be deleted before going to production
		if (item._owner != "mta")
		{
			item._url = "http://207.251.86.237/cctv" + item._camNumber + ".jpg";
		}

		//we create a marker object to push into the markercluster array only is the visible property is set to 1 or true
		if (item._visible == 1)
		{
			var marker = makeCameraMarker(item);
		}

		//push the marker into the array
		myCameraMarkers.push(marker);
	}

	//create a new amrker manager object to set on the map and control the many markers
	//i comment this out since i dont want to show the cameras when the map loads, but the array
	//with the camera objects is still filled, so if the user wants to see the cameras they would select
	//them from the menu

	/*
	 markerCluster = new MarkerClusterer(map, myCameraMarkers,
	 {
	 styles : cctvClusterStyle
	 });
	 */

}

/**
 *
 * makeCameraMarker makes the google map marker for the camera object that will be displayed on the map.
 * cam is a camera object that is passed from the calling function. it holds all the camera
 * information neccessary to make the camera marker
 * @param {object} cam
 *
 * @return {google.maps.Marker} a google map Marker object with included event listener for onclick events.
 */
function makeCameraMarker(cam)
{
	var camName = cam._name;
	var camUrl = cam._url;
	var camPosition = new google.maps.LatLng(cam._lat, cam._lon);
	var camStatus = 1;
	var camIcon;
	//get the logos
	switch(cam._owner) {
		case "MTA":
			var logo = logo_mta;
			break;
		case "nycdot":
			var logo = logo_nyc;
			break;
		case "nysdot":
			var logo = logo_nys;
			break;
		default:
			var logo = null;
	}

	google.maps.event.addDomListener(cameraInfoWindow, 'domready', modifyInfoWindowCss);
	//google.maps.event.addListener(cameraInfoWindow, 'closeclick', stopCameraInfoWindow);

	//set the icon based on the status. i defaulted to status 1 for now to show all cameras and don't bother to change the icon.
	//for production you need to use this var to set the correct icon
	if (camStatus == 1)
	{
		var img =
		{
			url : cctv_good,
			size : new google.maps.Size(20, 20),
			origin : new google.maps.Point(0, 0),
			anchor : new google.maps.Point(0, 0)
		};
	}
	else
	{
		var img =
		{
			url : cctv_fail,
			size : new google.maps.Size(20, 20),
			origin : new google.maps.Point(0, 0),
			anchor : new google.maps.Point(0, 0)
		};
	}

	camIcon = img;
	//create the marker and set the options object
	var camMarker = new google.maps.Marker(
	{
		position : camPosition,
		icon : camIcon,
		title : camName
	});

	google.maps.event.addListener(camMarker, 'click', function()
	{
		var iwContents = CameraIW(camName, camUrl, logo, camPosition);
		var timerErrorCount = 0;
		stopCameraInfoWindow();
		cameraInfoWindow.setContent(iwContents);

		cameraInfoWindow.open(map, this);

		cameraTimer.Tick = function()
		{
			//jquery line to refresh the image url with a new date object to bust the cache
			$('#myImg').error(function()
			{
				timerErrorCount++;
				console.log("error loading image");
				console.log("timer error count: " + timerErrorCount);
				if (cameraTimer.Enable && timerErrorCount >= 10)
				{
					console.log("timer error count: " + timerErrorCount);
					cameraTimer.Stop();
					cameraTimer.Enable = false;
					console.log('no good image src in over 10 refresh cycles; the timer has stopped');
				}
			}).attr('src', camUrl + '?d=' + cameraTimer.currentCount);

			//this is a trace to the console...it can be commented out when going to production.
			console.log("timer-tick for camera image:" + cameraTimer.currentCount + " for url: " + camUrl);
		};
		cameraTimer.Start();
	});
	return camMarker;
}

//this is to modify the infowindow css once it's created. the main stylesheet handles the dimensioning of the window, this handles
//modifying the infowindow once the image is loaded
function modifyInfoWindowCss()
{
	var c = document.querySelector(".gm-style-iw");

	//these lines change the right and width css elements of the infowindow so that the close button "floats" on top of the content added to the window
	c.style.setProperty("right", c.style.left, "important");
	c.style.setProperty("margin", "0 auto");
	c.style.setProperty("padding-left", "0");
	c.style.setProperty("padding-right", "0");

	//the lines below affect the infowindow close button. you can use this path in the DOM to change other css
	//c.nextElementSibling.style.setProperty("position", "absolute");
	c.nextElementSibling.style.setProperty('display', 'none', 'important');
	//c.nextElementSibling.style.setProperty('top', '30');
	//this value moves the clsoe button up and down
	//c.nextElementSibling.style.setProperty('right', '0');
	//this value moves the close button left and right.
	//c.nextElementSibling.style.setProperty('border', '1px dotted red');

	//the lines below affect the infowindow class itself. you can use this path in the dom to change other css
	//c.parentNode.style.setProperty('border','2px dotted black');

}

function stopCameraInfoWindow()
{
	console.log("camera infowindow closed\ntimer stopped");
	if (cameraTimer.Enable)
	{
		cameraTimer.Stop();
		cameraTimer.Enable = false;
		cameraInfoWindow.close();
	}

}

function ontilesloaded()
{
	console.log('tiles loaded...so begin the loading of the weborb objects');
	//invoke weborb server
	invokeServer(true);
}

/**
 * the showChart function will 'pop up' the overlay div which is hidden intially through css. once a call to this function is made, the
 * modal pop up will show. The important things to rememeber are the css for the overlay div and to put it at the end of your document
 * after the </html> tag.
 */
function showChart(link)
{

	//console.log('showing chart');
	var el = document.getElementById("overlay");
	var oc = document.getElementById("overlayContent");
	var closeButton = document.getElementById("closeBtn");
	var chartPopUp = new PolylineInfoWindowControl(link);

	el.style.visibility = "visible";
	el.style.opacity = 1;
	el.style.filter = 'alpha(opacity=100)';
	//this is needed for IE9+ since opacity property doest work, instead ie uses filter
	oc.appendChild(chartPopUp);
}

/**
 * the closeChart function is bound to the close button element onclick event. it will clear the modal chart from the screen
 * please note that you must define the actual chart element and it's parent to delete it from the stage
 */
function closeChartIw()
{
	var el = document.getElementById("overlay");
	//this is the actual overlay node that will dissapear
	var chartDiv = document.getElementById("chartWrapper");
	//chart2 is the id of the node that holds the chart. it should be in the DOM before we clear the overlay from the screen.
	chartDiv.parentNode.removeChild(chartDiv);
	//we call the parent of the chart node to remove the child.

	el.style.opacity = 0;
	//we set the opacity back to zero to reset the transition effect
	el.style.filter = 'alpha(opacity=0)';
	el.style.visibility = "hidden";
	//we clear the overlay from the screeen

	//chartData and chart are object for the amchart in the mycustomcontrols lib
	chartData = [];
	chart.clear();
	clearInterval(refreshLiveDataTimer);
}

//event listener on the dom to load the map
google.maps.event.addDomListener(window, 'load', initialize);

